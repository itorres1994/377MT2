\setcounter{chapter}{8}
\chapter{Monitors and Condition Variables}

\section{What's wrong with \defn{semaphors}?}
\begin{itemize}
    \item are shared global variables
    \item no linguistic connection between semaphores and data they control
    \item can be accessed from anywhere
    \item dual purposed (mutex and sched constraints)
    \item no guarantee of proper usage
\end{itemize}

Solution: use a higher level construct

\section{Monitors}
A monitor is similar to a class that ties data/operations and
synchornization together. \\

They differ from classes by guaranteeing mutual exlusion and requiring all data
to be private.

\begin{dfn} 
    \begin{enumerate}
        \item (From Wikipedia) A \defn{monitor} is a synchronization construct
            that allows threads to have both mutual exclusion and the ability to
            wait (block) for a certain condition to become true.
        \item (From slides) A \emph{monitor} is a defines a \emph{lock} and zero
            or more \emph{condition variables} for managing concurrent access to
            shared data.
            \begin{itemize}
                \item Monitors use a \emph{lock} to ensure that only a single
                    thread is active in the monitor at a given time
                \item The \emph{lock} also provides mutual exclusion for shared
                    data
                \item \emph{Condition variables} enable threads to go to sleep
                    inside the critical sections, by releasing their lock at the
                    same time it puts the thread to sleep

            \end{itemize}
    \end{enumerate}
\end{dfn}

Monitor Operations:
\begin{itemize}
    \item Encapsulates shared date to protect
    \item Acquires the mutex at start
    \item Operates on the shared data
    \item Temporarily release mutex if it can't complete
    \item Reqcquires the mutex when it can continue
    \item Releases the mutex at the end
\end{itemize}

\subsection{Implementing Monitors in Java}

It is simple to turn a Java class into a monitor:

\begin{itemize}
    \item Make all data private
    \item Make all methods synchronized (or at least the non-private ones)
\end{itemize}

\begin{verbatim}
class Queue{
    private data;     // queue data

    public void synchronized Add(Object item) {
        put item on queue;
    }

    public void synchronized Remove(){
        if (queue not empty){
            remove item;
            return item;
        }
    }
}
\end{verbatim}

\section{Condition Variables}
\textbf{Question:} How can we change \texttt{remove()} to wait until something
is on the queue?
\begin{itemize}
    \item Logically, we want to go to sleep inside the critical section.
    \item But if we hold on to the lock and sleep, then other threads cannot
        access shared queue, add an item to it, and wake up the sleeping thread.
    \item \textbf{THREAD COULD SLEEP FOREVER}
\end{itemize}

\textbf{Solution:} use condition variables
\begin{itemize}
    \item Condition variables enable a thread to sleep inside a critical section
    \item Any lock held by the thread is atomically released when the thread is
        put to sleep.
\end{itemize}

\subsection{Operations on Condition Variables}
\begin{dfn}
    A \defn{condition variable} is a queue of threads waiting for something
    inside a critical section.
\end{dfn}

Condition variables support three operations:
\begin{enumerate}
    \item \texttt{Wait()}\index{wait}: atomic (release lock, go to sleep). When the
        process wakes up it re-acquires the lock
    \item \texttt{Signal()}\index{signal}: wake up waiting thread, if one exists.
    \item \texttt{Broadcast()}\index{broadcast}: wake up all waiting threads.
\end{enumerate}

\textbf{Invariant:} a thread must hold the lock while doing condition variable
operations.

In java, we use \texttt{wait()} to give up the lock, \texttt{notify()} to signal
that the condition a thread is waiting on is satisfied, \texttt{notifyAll()} to
wake up all waiting threads. Effectively there is one condition variable per
object.

\begin{verbatim}
class Queue{
    private Object[] queue;    // queue data

    public void synchronized Add(Object item) {
        queue.append(item);
        notify();
    }

    public Object synchronized Remove(){
        while (queue.size == 0)
            wait();           // Give up lock and go to sleep

        remove and return item;
    }
}
\end{verbatim}
